\documentclass[table, 12pt]{article}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{tocloft}
\usepackage{todonotes}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{pdflscape}
\usepackage{textpos}
\usepackage{scrhack}
\usepackage{xcolor}
\usepackage{float}
\usepackage{longtable}
\usepackage{enumitem}
\usepackage{tasks}
\usepackage{tabularx}
\usepackage{titlesec}
\usepackage{listing}
\usepackage{graphicx}
\usepackage{subcaption}


\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\begin{document}
\begin{titlepage}
    \centering
    {\scshape\large AY 2020/2021 \par}
    \vfill
    \includegraphics[width=100pt]{assets/logo-polimi-new}\par\vspace{1cm}
    {\scshape\LARGE Politecnico di Milano \par}
    \vspace{1.5cm}
    {\huge\bfseries Implementation Document \par}
    \vspace{2cm}
    {\Large {Luca Pirovano\quad Nicolò Sonnino}\par}
    \vfill
    {\large Professor\par
        Matteo \textsc{Rossi}}
    \vfill
    {\large \textbf{Version 1.1} \\ \today \par}
\end{titlepage}
\hypersetup{%
    pdfborder = {0 0 0}
}
\thispagestyle{plain}
\pagenumbering{gobble}
\mbox{}
\newpage
\pagenumbering{roman}
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction}
\subsection{Purpose}
This document aims to describe how the implementation and integration testing took place.
Implementation is the last step of the CLup application development cycle.

Testing, instead, means check that the critical parts of the application works in a correct way, as described in the DD document.

The code and the releases can be find on the official CLup repository hosted on GitHub, reachable at this link:\\ \href{https://github.com/PiroX4256/SE2-Piemonti-Pirovano-Sonnino}{https://github.com/PiroX4256/SE2-Piemonti-Pirovano-Sonnino}.

\subsection{Definitions, Acronyms, Abbreviations}
\subsubsection{Acronyms}
\begin{itemize}
    \item \textbf{DBMS:} DataBase Management System.
    \item \textbf{DD:} Design Document.
    \item \textbf{DTO:} Data Transfer Object, represents a link between the user input and a Java Object.
    \item \textbf{QR Code:} Quick Response Code.
    \item \textbf{RASD:} Requirements Analysis and Specification Document.
    \item \textbf{S2B:} Software To Be.
\end{itemize}

\subsection{Revision history}
\begin{itemize}
    \item January 28, 2021: version 1.0 (first release)
    \item February 7, 2021: version 1.1 (fixed some typos)
\end{itemize}

\subsection{References}
\label{references}
\begin{itemize}
    \item \textbf{Dart} \href{https://dart.dev/}{https://dart.dev/}
    \item \textbf{Easy Loading} \href{https://pub.dev/packages/easy_loading}{https://pub.dev/packages/easy\_loading}
    \item \textbf{Flutter Barcode Scanner} \href{https://pub.dev/packages/flutter_barcode_scanner}{https://pub.dev/packages/flutter\_barcode\_scanner}
    \item \textbf{Flutter Local Notification} \href{https://pub.dev/packages/flutter_local_notifications}{https://pub.dev/packages/flutter\_local\_notifications}
    \item \textbf{Flutter Printing} \href{https://pub.dev/packages/printing}{https://pub.dev/packages/printing}
    \item \textbf{Flutter} \href{https://flutter.dev/}{https://flutter.dev/}
    \item \textbf{Font Awesome} \href{https://fontawesome.com/}{https://fontawesome.com/}
    \item \textbf{Google Fonts} \href{https://fonts.google.com/}{https://fonts.google.com/}
    \item \textbf{Google Maps Flutter} \href{https://pub.dev/packages/google_maps}{https://pub.dev/packages/google\_maps}
    \item \textbf{Hive} \href{https://pub.dev/packages/hive}{https://pub.dev/packages/hive}
    \item \textbf{Java: } \href{https://www.java.com/it}{https://www.java.com/it}
    \item \textbf{JavaScript: } \href{https://www.javascript.com}{https://www.javascript.com}
    \item \textbf{jQuery: } \href{https://jquery.com}{https://jquery.com}
    \item \textbf{Kotlin} \href{https://kotlinlang.org/}{https://kotlinlang.org/}
    \item \textbf{Leaflet.js} \href{https://leafletjs.com}{https://leafletjs.com}
    \item \textbf{Pull to refresh} \href{https://pub.dev/packages/pull_to_refresh}{https://pub.dev/packages/pull\_to\_refresh}
    \item \textbf{QR Flutter} \href{https://pub.dev/packages/qr_flutter}{https://pub.dev/packages/qr\_flutter}
    \item \textbf{QRcode.js: } \href{https://jquery.com}{https://jquery.com}
    \item \textbf{Semantic UI: } \href{https://semantic-ui.com}{https://semantic-ui.com}
    \item \textbf{Spring Framework: } \href{https://spring.io}{https://spring.io}
    \item \textbf{Spring Security: } \href{https://spring.io/projects/spring-security}{https://spring.io/projects/spring-security}
    \item \textbf{Spring Social: } \href{https://projects.spring.io/spring-social}{https://projects.spring.io/spring-social}
    \item \textbf{Swift} \href{https://www.apple.com/it/swift/}{https://www.apple.com/it/swift/}
    \item \textbf{Url Launcher} \href{https://pub.dev/packages/url_launcher}{https://pub.dev/packages/url\_launcher}
    \item \textbf{Vue.js: } \href{https://vuejs.org}{https://vuejs.org}
\end{itemize}

\newpage
\section{Development}
\subsection{Implemented Functionalities}
With respect to the RASD and DD documents, we decided to implement the following functions:
\begin{itemize}
    \item \textbf{Sign Up}
    \item \textbf{ASAP: As Soon As Possible}
    \item \textbf{Hand out tickets on spot}
    \item \textbf{Periodic notifications}
\end{itemize}
For more details regarding the specific functionalities, you are invited to read the RASD document, which contains a very detailed description of them.

We chooses to implement these functionalities in order to simulate a Module 1 product purchase. In fact, we remind that the application is divided into three modules; the first one is also called \textit{MVP}, and contains the basic functionalities of CLup, the second one contains the \textit{Book a Visit} feature and the last one includes the custom deploy on organization's servers.

In a real-world scenario, the most used module would be of course the first one (due to its simplicity), so that we decided to focus on it.

\subsection{Adopted Development Frameworks}
As we said in our DD, the application should follow a four-tier architecture, with a fully REST interface and a lot of client scripting. Finally, we decided to adopt the Model-View-Controller pattern, which is one of the most used in distributed applications.

In the following pages you will find a list of adopted frameworks and technologies in order to accomplish to this requirements.

\subsubsection{Programming languages}
For sake of standards and application speed we decided to use the Java\texttrademark  Programming Language, which is one of the most used languages in web and distributed applications.

Of course, there are some pros and cons about using this type of language:
\\\begin{itemize}
    \item \textbf{Pros:}
          \begin{itemize}
              \item[+] Speed: of course, since it is a compiled language, Java permits to have very good performances on these elaborations;
              \item[+] Standard: as shown in figure \ref{languages_comparison}, Java is the \textit{De Facto standard} in enterprise web development and represents a very good solution for portable applications;
              \item[+] Stability: Java is a mature language that has immensely evolved over the years. Hence it’s more stable and predictable.
              \item[+] Object-Oriented: The object-oriented nature of Java allows developers to create modular programs and write reusable codes. This saves lots of efforts and time, improving the productivity of the development process.
              \item[+] Well-documented
          \end{itemize}
    \item \textbf{Cons:}
          \begin{itemize}
              \item High verbosity: with respect to other programming languages (such as Python), Java contains a more verbose and less-readable syntax.
              \item High memory consumption: since Java Programs run on top of Java Virtual Machine, it consumes more memory.
          \end{itemize}
\end{itemize}

For the client-side scripting, we decided to adopt JavaScript\texttrademark  for the web app, and Flutter with Dart\texttrademark  language for the mobile app.

JavaScript is a text-based programming language used both on the client-side and server-side that allows to make web pages interactive. Where HTML and CSS are languages that give structure and style to web pages, JavaScript gives web pages interactive elements that engage a user.

Flutter, instead, is an open-source UI software development kit created by Google. It is mostly used to develop applications for Android and iOS.\\
The main functionality of this framework is the versatility of the Dart programming language, which lets compile application both in Swift (iOS) and Kotlin (Android).  

\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/graph-18-19-languages.jpg}
    \caption{Web Programming languages usage (2018 vs 2019)}
    \label{languages_comparison}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/client-side-scripting.png}
    \caption{Client-side technologies}
\end{figure}

\subsection{Java Frameworks}
\subsubsection{Spring}
\label{spring}
In order to accomplish the S2B requirements, we decided to adopt the Spring development framework.

Spring is an open source framework, used for RESTful Java application development. It's built on top of the Java Enterprise Edition (JEE) and represents an efficient and modern alternative to the classic Enterprise Java Bean (EJB) model.

Of course, using a framework means works on a solid base, which is well tested and documented. In fact, Spring contains a proper paradigm in order to build web services on its API.

\begin{figure}
    \includegraphics[width=\textwidth]{assets/SpringArchitecture.png}
    \caption{Spring Framework architecture}
    \label{spring_architecture}
\end{figure}

As shown in figure \ref{spring_architecture}, the architecture of Spring is very simple and easy-to-use.

In fact, it is composed by:
\begin{itemize}
    \item \textbf{Dispatcher Servlet:} its job is to route all the incoming requests to the correct Spring controller, which is properly mapped with an appropriate annotation. This is done through the severals components of Spring, which are HandlerMapping, HandlerAdapter and ViewResolver.
    \item \textbf{Controller:} the controller acts as an interface between the user and the services. It catches the requests coming from the dispatcher and makes actions relying on what user passed to it.
    \item \textbf{Model:} it contains the application logic about the transfer objects (also called DTO) which maps a user input (which is encoded in JSON format) and a Java object. The DTOs can also be used in the opposite direction (server to client), so they are encoded in JSON format and then sent to the client.
    \item \textbf{Services:} they act as an intermediate between the entities (database objects) and the controller, containing some useful methods in order to manipulate data sent by controllers.
    \item \textbf{Repositories:} they are interfaces that contains the query methods in order to fetch data from database. They are managed from Spring engine and it suffices to specify what to retrieve in order to get a response object from the DBMS.
    \item \textbf{Entities:} they represent database objects. They are declared with @Entity annotation, which maps the object to a database table (or set of them). Inside an entity object it is possible to specify constraints and foreign references through proper annotations.
\end{itemize}

\subsubsection{Spring Data JPA}
Spring Data JPA, part of the larger Spring Data family, permits to easily implement JPA based repositories. This module deals with enhanced support for JPA based data access layers. It makes it easier to build Spring-powered applications that use data access technologies.

Spring Data JPA aims to significantly improve the implementation of data access layers by reducing the effort to the amount that’s actually needed.

In fact, through services and repositories, interfacing with the database becomes very simple. Useless to say that, furthermore, the security of the queries from SQL injection is high, because it is totally managed by Spring.

\subsubsection{Spring Security}
Spring Security is a plugin of the Spring Mvc suite, which manages the application security.

In fact, it is role-based and permits, through several annotations, to grant access to controller only to authorized people.

In CLup, Spring Security is also the responsible for the REST authentication, which is made through a pattern called JWT (Json Web Token).

Practically, it is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.
In our case, there is an exchange of a token which authorizes each client request, so the client needs to attach it to request's headers each time it calls the server.
\subsubsection{Spring Social}
Spring Social is another plugin of the Spring family which permits the user authentication through several identity providers (IdPs).

For sake of simplicity, we decided to start from the Facebook one, which is one of the most used social network nowadays. Once called, Facebook servers authenticate the user and return back to the CLup backend its information, which generally consists of name, surname and profile id.

Obviously, the same can be done with the other identity providers, such as Google, Twitter, GitHub, etc.

\subsection{Other Frameworks}
\label{client_side_frameworks}
\subsubsection{Vue.js}
Vue is a progressive framework for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with modern tooling and supporting libraries.

We used Vue.js to manage the client-side rendering of the pages on the web app. In fact, each page calls its scripts, which are responsible for the correct orchestration.
\subsubsection{jQuery}
jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. With a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript.

We used jQuery to implement the network layer of the client-side web application. In fact, it is responsible (through the Ajax plugin) of the communication with the server, managing all the requests and response.

\subsubsection{QRcode.js}
QRCode.js is javascript library for making QRCode. QRCode.js supports Cross-browser with HTML5 Canvas and table tag in DOM. QRCode.js has no dependencies.

We used this library in order to generate a visual representation, through a Quick Response Code (also known as QRCode), of the ticket unique id, in order to easily permit its validation at the supermarket entrance.

\subsubsection{Semantic UI}
Semantic UI is a graphical framework which is useful to construct good-looking web interfaces with less effort than making them manually.

It includes several css styles, together with a full JavaScript set of functionalities (such as dynamic management of the page).
\subsection{API Integrations}
\subsubsection{Leaflet.js}
Leaflet is an open source JavaScript library used to build web mapping applications.

We used it to render the maps containing stores position, in the user and manager private area.
\newpage
\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/FlutterArchitecture.png}
    \caption{Flutter Framework architecture}
\end{figure}
\subsection{Mobile Frameworks}
\subsubsection{Flutter}
Flutter is designed as an extensible, layered system. It exists as a series of independent libraries that each depend on the underlying layer. No layer has privileged access to the layer below, and every part of the framework level is designed to be optional and replaceable.\\
At the core of Flutter is the Flutter engine, which is mostly written in C++ and supports the primitives necessary to support all Flutter applications.\\
It includes a rich set of platform, layout, and foundational libraries, composed of a series of layers. Working from the bottom to the top, we have:

\begin{itemize}
    \item Basic \textbf{foundational classes}, and building block services such as animation, painting, and gestures that offer commonly used abstractions over the underlying foundation.
    \item The \textbf{rendering layer} provides an abstraction for dealing with layout. With this layer, you can build a tree of renderable objects. You can manipulate these objects dynamically, with the tree automatically updating the layout to reflect your changes.
    \item The \textbf{widgets layer} is a composition abstraction. Each render object in the rendering layer has a corresponding class in the widgets layer. In addition, the widgets layer allows you to define combinations of classes that you can reuse. This is the layer at which the reactive programming model is introduced.
    \item The \textbf{Material} and \textbf{Cupertino} libraries offer comprehensive sets of controls that use the widget layer’s composition primitives to implement the Material or iOS design languages.
\end{itemize}
\subsubsection{Hive}
Hive is a lightweight and blazing fast key-value database written in pure Dart.\\
It has the of Model in the MVC pattern used in the Mobile App as some information are stored on the client in order to improve performance.\\
It uses HiveObjects as basic structure which are then implemented or extended through TypeAdapters.
\subsubsection{QR Flutter}
QR.Flutter is a Flutter library for simple and fast QR code rendering via a Widget or custom painter.\\
It implements QrImage and QrPainter widgets which are responsible for the correct realization of QR codes.
\subsubsection{Flutter Barcode Scanner}
Flutter Barcode Scanner is a plugin for Flutter apps that adds barcode scanning support on both Android and iOS.\\
It's especially useful because it interfaces with the mobile's cameras and implements QR code's scanning out of the box.
\subsubsection{Google Maps Flutter}
It's a Flutter plugin that provides a Google Maps widget and easy interface with Google API.\\
\subsubsection{Path Provider}
A Flutter plugin for finding commonly used locations on the filesystem. Supports iOS, Android, Linux and MacOS (vital for the correct model managing).
\subsubsection{Printing \& Http}
The first plugin provides easy API for accessing native Android printing services, instead the second one lets access HTTP GET/POST requests which are a core functionality in our implementation.\\\\

The remaining frameworks help with minor functionalities and can be found in the References section[\ref{references}].\newpage
\section{Source Code}
\subsection{Backend}
The backend is packaged through the Maven framework, which gives also a standard for organizing the code. Of course, we followed this standard, merged with the Spring Framework one.

More details about the maven projects standard organization can be found at \href{https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html}{https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html}
\subsubsection{Packages}
As previously said, the application backend is built on top of the Spring Framework, which follows an architectural pattern called Model View Controller (MVC). The extension of the MVC provided by Spring defines also a standard structure of the project classes.

\subsubsection*{Package it.polimi.se2.clupapplication}
\begin{itemize}
    \item \textbf{Config:} this package contains the configuration classes of Spring framework, which manage security and general application configuration.
    \item \textbf{Controllers:} it contains all the controllers of CLup application, following the Spring controllers paradigm. See section \ref{spring_architecture} for more details.
    \item \textbf{Entities:} this package contains all the relational database objects, which are properly mapped to a SQL server through the JPA APIs. Each table has its own entity class, with the exception of the bridge (OneToOne, OneToMany, ManyToMany) relations.
    \item \textbf{Model:} following Spring standard, this package includes all the DTO (Data Transfer Objects) for data exchange between client and server.
    \item \textbf{Repositories:} it contains the Spring repositories, which are the interfaces required in order to query the DBMS and the related entities.
    \item \textbf{Security:} part of the Spring plugins, this package includes the security classes of CLup application. In fact, these classes manages the process of login and sign up through the exchange of the JWT (Json Web Token). Furthermore, they also implement the IdP sign in feature with social networks (such as Facebook).
    \item \textbf{Services:} this last package contains the service classes, which are the intermediates between controllers and repositories, following the Spring approach described in section \ref{spring_architecture}.
\end{itemize}

\subsubsection{Flow of a request}
\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/Spring-MVC-Flow-Diagram.jpg}
    \caption{Flow of a client request to backend}
    \label{spring_mvc_request}
\end{figure}
As you can see in figure \ref{spring_mvc_request}, a request coming from a client follows several step into the backend structure.

First of all, it is intercepted by the Dispatcher Servlet, which forwards the request to the URL Handler Mapping. This handler contains the mapped urls from all the application controller and also the method accepted (GET, POST, PUT, etc.).

Once URL Handler has resolved the associated controller, the request is dispatched to the correct controller, which calls the classes needed for elaboration (such as services and, consequently, repositories).

After the elaboration, the controller creates a ResponseEntity object and sends it to the view resolver which, with the help of Views class, return the response to Dispatcher Servlet.

Finally, the Dispatcher Servlet return the created response to the client.

\subsubsection{Test cases}
The test cases, which are described in details in section \ref{testing}, are located under the maven \textit{test} folder, into the package it.polimi.se2.clupapplication.

\subsection{Frontend Structure}
\subsubsection{Web Application}
The front-end web application is contained into the \textit{resources/public} folder of the Spring application, in order to permit an easy reachability directly from the backend dispatcher without being filtered from the security manager.
Of course, following the four tier architecture described in the Design Document, the front-end web application can also be deployed to a dedicated web server, which will then make requests to a different backend server.

The structure of the web app is the following:
\begin{itemize}
    \item \textbf{admin:} this folder contains all the administration HTML web pages, which are served with the \textit{/admin} url prefix;
    \item \textbf{attendant:} this folder, instead, contains all the attendant dashboard HTML web pages, which are served with the \textit{/attendant} url prefix;
    \item \textbf{static:} this last folder contains all the static files of the web application, which consists of CSS stylesheets, JS scripts, fonts, images and client-side frameworks adopted (see section \ref{client_side_frameworks});
    \item all the other HTML files in \textit{public} directory refer to the customer web interface, which will be of course the most used pages.
\end{itemize}
\newpage
\subsection{Mobile App}
The mobile code implemented follow the MVC pattern with minor differences.\\
In addition to the architecture, Flutter creates different directories and files:
\begin{itemize}
    \item \textbf{android}, containing native Kotlin code;
    \item \textbf{ios}, containing native Swift code;
    \item \textbf{lib}, the folder where your app is placed (Dart);
    \item \textbf{pubspec.yaml}, file specifying your app's version, plugin imported and assets used.
\end{itemize}

\subsubsection{Package it.polimi.clup}
In the \underline{lib} folder, our mobile app is organized with the MVC pattern as follows:
\begin{itemize}
    \item \textbf{model}: it contains all HiveObject used to store information on the client.
    \item \textbf{pages}: package containing all mobile app's screens, divided in \textbf{StatefulWidgets} or \textbf{StatelessWidget}. It represents the View in the MVC pattern.
    \item \textbf{widgets}: analogous to the above package, it contains individual widgets (used in pages) in order to increase readability and reuse components multiple times in the mobile app (FormFields, AppBars etc.).
    \item \textbf{utils}: this package contains the controller component specified in the MVC pattern; it contains the following components which sends REST API to the Application Server: \textbf{AuthService} (authentication), \textbf{Generator} (booking/ticket manager) and minor utility classes.
    \item \textbf{theme}: folder containing files for theming.
\end{itemize}

\subsubsection{Platform channels}
\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/FlutterFlow.png}
    \caption{Platform channels}
    \label{spring_mvc_request}
\end{figure}
For mobile and desktop apps, Flutter allows you to call into custom code through a platform channel, which is a simple mechanism for communicating between your Dart code and the platform-specific code of your host app.\\
By creating a common channel (encapsulating a name and a codec), you can send and receive messages between Dart and a platform component written in a language like Kotlin or Swift.\\
Data is serialized from a Dart type like Map into a standard format, and then deserialized into an equivalent representation in Kotlin (such as HashMap) or Swift (such as Dictionary).
\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/inherited-widget.png}
    \caption{Platform channels}
    \label{spring_mvc_request}
\end{figure}
The framework introduces two major classes of widget: \textit{stateful} and \textit{stateless widgets}.\\
Many widgets have no mutable state: they don’t have any properties that change over time (for example, an icon or a label). These widgets subclass \textbf{StatelessWidget}.\\
However, if the unique characteristics of a widget need to change based on user interaction or other factors, that widget is \textit{stateful}. For example, if a widget has a counter that increments whenever the user taps a button, then the value of the counter is the state for that widget. When that value changes, the widget needs to be rebuilt to update its part of the UI. These widgets subclass \textbf{StatefulWidget}, and (because the widget itself is immutable) they store mutable state in a separate class that subclasses \textbf{State. StatefulWidgets} don’t have a build method; instead, their user interface is built through their \textbf{State} object.\\
Whenever you mutate a State object (for example, by incrementing the counter), you must call \textbf{setState()} to signal the framework to update the user interface by calling the State’s build method again.\\
Having separate state and widget objects lets other widgets treat both stateless and stateful widgets in exactly the same way, without being concerned about losing state. Instead of needing to hold on to a child to preserve its state, the parent can create a new instance of the child at any time without losing the child’s persistent state. The framework does all the work of finding and reusing existing state objects when appropriate.


\subsection{Other Useful Information}
The application is configured to fetch data from a MySQL database, which credentials must be specified in the application.yaml properties file. This configuration file can be found in \textit{resources} folder and contains also all the other static configurations of the application, such as jpa configurations, social login credentials, jwt token settings, etc.
\newpage
\section{Testing}
\label{testing}
In this section we will briefly describe how we tested the application, following the general guidelines given in the Design Document.

We decided to test only the backend and mobile app deployable, because the front-end can be easily tested "by seeing it working".
\subsection{Backend}
We wrote the test cases using the JUnit 5 suite and, for mocking the user in the requests, the Spring Security Testing Suite.

Following the suggested Spring testing approach, we wrote the integration test cases for the controller classes, because of their primary role in request-response flow.

In fact, testing a controller means test also all the other components (services, repositories, entities, etc.), because they are sequentially called from it.

Up next you'll find a complete report on how we did the test cases, and also their results.

\subsubsection*{Integration Tests}
\begin{itemize}
    \item \textbf{UserController:} we tested the Sign Up and login methods, as defined in the DD. In the sign up tests, we tried with both a Customer and a Store Manager profiles. Finally, we tested the correct exchange of the Json Web Token between the parties.
    \item \textbf{StoreController:} we tested the store and slot creation functions. We defined a mock store manager, in order to correctly test that the permission based access would correctly handle the request.
    \item \textbf{TicketController:} we tested the procedure of ASAP (As Soon As Possible) ticket retrieving functionality. Furthermore, we defined a mock store attendant, in order to test also the \textbf{Hand Out on Spot} function.
\end{itemize}

The above test, which were in total 13, were run all together, obtaining a percentage of success of 100\%.

Thanks to the obtained result it is therefore possible to state that the backend is sturdy and built on solid source code.

\subsubsection*{Unit Tests}
Furthermore, we made some tests on the correct DBMS initialization, through a specific JPA Test construct. They all obtained a positive mark.
\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/mvn.png}
    \caption{Maven test report}
\end{figure}
\subsection{Mobile Application}
Integration testing is possible in Flutter, but Widgets have very strict assertions on input data; another very useful functionality of this framework is \textit{hot reload} and \textit{hot restart} which let runtime testing while coding it and without rebuilding it.\\
We decided that integration on widgets was very time consuming and not worth it compared to the effort spent.\\
Instead we tested our application on daily basis but more importantly we deployed our application \textit{APK} and \textit{IPA} on \textbf{TestFlight} (Apple's App Store for beta builds) and \textbf{Google Play Store}.\\
Once the builds were approved by Google/Apple we invited about 20 testers in order to stress the app and receive constant feedbacks, using them as the baseline for each new update. 
\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/console.png}
    \caption{Google Play build report}
\end{figure}
\begin{figure}[H]
    \includegraphics[width=\textwidth]{assets/testflight.png}
    \caption{Apple's TestFlight report}
\end{figure}

\section{Build}

\subsubsection{Requirements}
\begin{itemize}
    \item Java SE JDK 15 (\textbf{\href{https://jdk.java.net/15/}{OracleJDK}}, \textbf{\href{https://openjdk.java.net/projects/jdk/15/}{OpenJDK}})
    \item \textbf{\href{https://maven.apache.org/}{Maven}} framework version 3.0 (or newer)
\end{itemize}

\subsection{Windows}\label{windows}


If you use
\textbf{\href{https://docs.microsoft.com/en-us/windows/wsl/install-win10}{Windows
        Subsystem for Linux (WSL)}} or \textbf{\href{http://mingw-w64.org/doku.php}{MinGW}} you
can skip to Linux installation steps.

\subsubsection{Installing Java}\label{installing-java}

Download \textbf{\href{https://jdk.java.net/15/}{OracleJDK}} or \textbf{\href{https://openjdk.java.net/projects/jdk/15/}{OpenJDK}}.

Extract content from the zip folder to your preferred location, then go
to
\texttt{Start\textgreater{}Edit the system environment variables\textgreater{}Environment Variables ...}

In the User Section select \texttt{Path} variable and click on
\texttt{Edit}; select \texttt{New} and type
\texttt{C:\textbackslash{}Users\textbackslash{}\textless{}your-user\textgreater{}\textbackslash{}\textless{}path-to-extracted-folder\textgreater{}\textbackslash{}bin},
then save and exit.

Open \texttt{Start\textgreater{}cmd.exe} and verify your Java version by
typing the following command:

\begin{verbatim}
java -version
\end{verbatim}

\subsubsection{Installing Maven}\label{installing-maven}

Download
\textbf{\href{https://mirror.nohup.it/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.zip}{Maven}}.

Extract to preferred location and repeat above steps.

Verify your Maven version by typing the following command:

\begin{verbatim}
mvn --version
\end{verbatim}

\subsection{Linux}\label{linux}

If you want to download Maven and JavaJDK with your package manager be
sure to fulfill the system requirements otherwise follow the next
steps.

\subsubsection{Installing Java}\label{installing-java-1}

Download JavaJDK based on your
\href{https://www.oracle.com/java/technologies/javase-jdk15-downloads.html}{distro}
or OpenJDK 15
\href{https://download.java.net/java/GA/jdk15.0.1/664493ef4a6946b186ff29eb326336a2/7/GPL/openjdk-15.0.1_linux-x64_bin.tar.gz}{here}.

\textbf{Linux Platforms}

Navigate to your preferred install location and extract the .tar.gz
archive file using:

\begin{verbatim}
tar zxvf jdk-15.<version-number>-x64_bin.tar.gz
\end{verbatim}

Now let's set the \texttt{PATH} variable by typing the following code:

\begin{verbatim}
cd $HOME 
nano .bashrc
\end{verbatim}

Add the following line to the end of \texttt{.bashrc}:

\begin{verbatim}
export PATH=/<path-to-extracted-folder/bin:$PATH
\end{verbatim}

Verify your Java version by typing the following command:

\begin{verbatim}
java -version
\end{verbatim}

\textbf{Debian-Based Linux Platforms}

Type:

\texttt{sudo apt install /path/to/package/name.deb}

Verify your Java version by typing the following command:

\begin{verbatim}
java -version
\end{verbatim}

\textbf{RPM-Based Linux Platforms}

Type the following command to install the package:

\begin{verbatim}
rpm -ivh jdk-15.<version-number>-x64_bin.rpm
\end{verbatim}

Upgrade the package using the following command:

\begin{verbatim}
rpm -Uvh jdk-15.<version-number>-x64_bin.rpm 
\end{verbatim}

You can now delete the \texttt{.rpm} file and verify your installation
by typing:

\begin{verbatim}
java -version
\end{verbatim}

\subsubsection{Installing Maven}\label{installing-maven-1}

Download
\textbf{\href{https://mirror.nohup.it/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz}{Maven}},
extract it with:

\begin{verbatim}
tar zxvf maven.<version-number>-x64_bin.tar.gz
\end{verbatim}

Set \texttt{PATH} variable by appending this command to \texttt{.bashrc}
as previous steps:

\begin{verbatim}
cd $HOME 
nano .bashrc
export PATH=/<path-to-extracted-folder/bin:$PATH
\end{verbatim}

\subsection{MacOS}\label{macos}

\subsubsection{Installing Java}\label{installing-java-2}

Download
\href{https://www.oracle.com/java/technologies/javase/jdk15-archive-downloads.html}{JavaJDK
    15}, double-click on \texttt{.dmg} file and \textbf{Install} it.

Verify your Java version by typing the following command:

\begin{verbatim}
java -version
\end{verbatim}

\subsubsection{Installing Maven}\label{installing-maven-2}

Follow Linux installation steps.


\subsection{Compiling the source files}
\begin{enumerate}
    \item Open the terminal and navigate to the root application folder (containing pom.xml).
    \item Type \texttt{mvn package -Dmaven.test.skip=true} and hit \texttt{Enter}.
\end{enumerate}
\paragraph{Why am I skipping maven test phase?}
Because since there is no data source connected, it cannot perform tests on it.\\
If you want to include the test phase, you will need to edit the \textit{application.yaml} file located under \texttt{src/main/resources} as specified in the Installation section. 



\section{Installation}\label{using-the-self-contained-installer-recommended}
Follow compiling installation steps without \textbf{Maven} section.
\subsubsection{Requirements}
\begin{itemize}
    \item Java SE JDK 15 (\textbf{\href{https://jdk.java.net/15/}{OracleJDK}}, \textbf{\href{https://openjdk.java.net/projects/jdk/15/}{OpenJDK}})
\end{itemize}
\subsection{Backend}
\subsubsection{Windows self contained installer}
\begin{enumerate}
    \item Download the executable file from \textbf{\href{https://github.com/PiroX4256/SE2-Piemonti-Pirovano-Sonnino/releases}{Release page}} on our Github repo.
    \item Install it following the wizard installation tool.
    \item Navigate to installation directory (usually \texttt{C:\textbackslash{}Program Files\textbackslash{}clupServer}).
    \item Edit the \textit{application.yaml} file under \textbf{app} folder:\\
          \paragraph{Spring.datasource}
          \begin{itemize}
              \item \textbf{url}: replace <url> with your database domain address and \textless{}db\_name\textgreater{} with the database's name.
              \item \textbf{username}: your database's administrator username.
              \item \textbf{password}: your database's administrator password.
          \end{itemize}
          \paragraph{Spring.mail}
          \begin{itemize}
              \item \textbf{host}: your SMTP server hostname.
              \item \textbf{username}: your SMTP sender username.
              \item \textbf{password}: your SMTP sender password.
          \end{itemize}
          \paragraph{Server.port}
          \begin{itemize}
              \item \textbf{port}: application server port.
          \end{itemize}
    \item Save and exit.
    \item Launch clupServer shortcut from your Desktop.
\end{enumerate}
\subsubsection{Cross-platform JAR Package}
\begin{enumerate}
    \item Download the zip archive from \textbf{\href{https://github.com/PiroX4256/SE2-Piemonti-Pirovano-Sonnino/releases}{Release page}} on our Github repo.
    \item Extract the two files in the same folder.
    \item Edit the \textit{application.yaml} as stated in the Windows self contained installer section.
    \item Launch it from your terminal with the following command:\\ \texttt{java -jar clup<version>.jar --spring.config.location=application.yaml}
\end{enumerate}
\subsection{Mobile Application}
\subsubsection{Store Builds}
Download the application based on your platform following the provided links:
\begin{figure}[H]
    \centering
    \href{https://play.google.com/store/apps/details?id=it.polimi.c_lup}{
        \begin{subfigure}{.4\textwidth}
            \includegraphics{assets/google.png}
        \end{subfigure}%
    }
    \href{https://testflight.apple.com/join/LPYEOhGr}{
        \begin{subfigure}{.4\textwidth}
            \includegraphics[scale=0.25]{assets/apple.png}
        \end{subfigure}%
    }
\end{figure}
\subsubsection{Github Builds (Android only)}
Download the application by accessing the Release page on our Github repo or by clicking the link \textbf{\href{https://github.com/PiroX4256/SE2-Piemonti-Pirovano-Sonnino/releases}{here}}. 
\section{Effort spent}
\begin{center}
    \begin{tabular}{ | c || c | c | c | c| c|}
        \hline
        Student        & Time for Implementation Project \\ \hline
        Luca Pirovano  & 70 hours                        \\ \hline
        Nicolò Sonnino & 70 hours                        \\
        \hline
    \end{tabular}
\end{center}
\end{document}